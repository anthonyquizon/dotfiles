set nocompatible autoindent laststatus=2 relativenumber nu smartcase nopaste nowrap expandtab 
set noswapfile nobackup nowritebackup shiftwidth=4 softtabstop=4 tabstop=4 is ttimeoutlen=100   " ttimeout to stop esc hanging on : commands
set backspace=indent,eol,start hlsearch path+=** wildmenu undofile undodir=~/.vim/undodir 
let g:netrw_banner = 0 | let mapleader = "\<Space>"
filetype indent on | syntax on 
ino jk <esc>| nn K <nop>| nn U <nop>
com! Qa qa | com! QA qa | com! Q q|                                                             " typo friendly commands. 'w' commands are separate lines (not |) Parser treats | as filename
com! WQ wq
com! Wq wq
com! W w
vm < <gv | vm > >gv|                                                                            " visual mode indenting
vn <leader>s "vy :%s/<C-R>v//g<Left><Left>|                                                     " search visual
vn <leader>S "vy :%s//<C-R>v/g<C-b><Right><Right><Right>|                                       " search visual
nn <leader>s :%sno/<C-R><C-W>//g<Left><Left>|                                                   " search
nn <leader>S :%sno//<C-R><C-W>/g<C-b><Right><Right><Right><Right><Right>|                       " search 
nn <leader>z :noh<CR>                                                                           " search  highlight
nn <leader>0 :set scroll=0<CR>                                                                  " scroll reset
vn  <C-y> "*y                                                                                   " yank into clipboard 
nn  <C-j> :m .+1<CR>==| nn <C-k> :m .-2<CR>==|                                                  " shuffle line one up or down Normal mode
ino <C-j> <Esc>:m .+1<CR>==gi| ino <C-k> <Esc>:m .-2<CR>==gi|                                   " shuffle line one up or down Insert mode
vn  <C-j> :m '>+1<CR>gv=gv| vn <C-k> :m '<-2<CR>gv=gv|                                          " shuffle line one up or down Visual mode

function! Fzy(cmd, act)
  try | let o = system(a:cmd . " | fzy ") | catch /Vim:Interrupt/ | endtry| " Swallow errors from ^C, allow redraw! below
  redraw!
  if v:shell_error == 0 && !empty(o) 
    let l=split(split(o, '\n')[0], ':') | 
    exec  a:act . ' ' . (len(l) > 1 ? '+'. l[1] : '') . ' ' . l[0]
  endif
endf
nn <leader><leader> :call Fzy("rg . -g '!.git/' -l --hidden 2>/dev/null", ":e")<cr>                                 " rg list files, suppress errors so that it doesn't mess up return value
nn <leader>/ :call Fzy("rg -n -g '!.git/' --hidden . 2>/dev/null", ":e")<cr>                                         " rg list lines, suppress errors

function! Comment(type, ...)
  let ms=split(substitute(substitute(&cms,'\S\zs%s',' %s',''),'%s\ze\S','%s ',''),'%s',1)
  let lhs=escape(substitute(ms[0],' ','',''),'*')|let rhs=escape(substitute(ms[1],' ','',''),'*')
  let r = a:0 ? "'<,'>" : "'[,']"
  if match(getline('.'), lhs) == 0
    exe "norm! :".r."s]^".lhs."]\<CR>`".(a:0?'<':'[') | exe "norm! :".r."s]".rhs."$]]\<CR>`".(a:0?'<':'[')
  else
    exe "norm! :".r."s]^]".lhs."\<CR>`".(a:0?'<':'[') | exe "norm! :".r."s]$]".rhs."\<CR>`".(a:0?'<':'[')
  endif
endf
no <leader>; :<C-u>set opfunc=Comment<bar>execute "norm! " . v:count1 . "g@_"<CR>
xn <leader>; :<C-u>call Comment(visualmode(), 1)<CR>

" BQN
scripte utf-8 
let a ='`1234567890-= ~!@#$%^&*()_+ qwertyuiop[]  QWERTYUIOP{} asdfghjkl;''\ ASDFGHJKL:"| zxcvbnm,./    ZXCVBNM<>?   '
let b ='˜˘¨⁼⌜´˝7∞¯•÷× ¬⎉⚇⍟◶⊘⎊⍎⍕⟨⟩√⋆ ⌽𝕨∊↑∧y⊔⊏⊐π←→  ↙𝕎⍷𝕣⍋YU⊑⊒⍳⊣⊢ ⍉𝕤↕𝕗𝕘⊸∘○⟜⋄↩\  ↖𝕊D𝔽𝔾«J⌾»·˙| ⥊𝕩↓∨⌊n≡∾≍≠    ⋈𝕏C⍒⌈N≢≤≥⇐   '
let[a,b]=map([a,b],{i,x->split(x,'\zs *')}) | let a+=['<space>']|let b+=['‿']
for l in ['i','c']| for i in range(len(a)) |
    exe escape(l.'no'.'\'.a[i].' '.b[i],'|')
endfor |endfor
unl a b l i

au BufRead,BufNewFile * if getline(1) =~ '^#!.*bqn$' | setf bqn | endif
au BufRead,BufNewFile *.bqn setf bqn

au FileType bqn syn match bqncom "#.*$"
au FileType bqn hi link bqncom comment
au FileType bqn setlocal softtabstop=2 tabstop=2 shiftwidth=2 expandtab commentstring=#%s

