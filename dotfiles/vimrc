scripte utf-8 
set shell=/bin/bash
set nocompatible autoindent laststatus=2 relativenumber nu smartcase nopaste nowrap expandtab hidden
set noswapfile nobackup nowritebackup shiftwidth=4 softtabstop=4 tabstop=4 is ttimeoutlen=100   " ttimeout to stop esc hanging on : commands
set backspace=indent,eol,start hlsearch path+=** wildmenu autoread undofile undodir=~/.vim/undodir 
set grepprg=rg\ --vimgrep|set complete= |set grepformat^=%f:%l:%c:%m|set viminfo='50,<5000,s100  " increase vim register limit so that we can copy more data between instances 
au FileType python setlocal noexpandtab softtabstop=4 tabstop=4 shiftwidth=4
au FileType c setlocal noexpandtab softtabstop=2 tabstop=2 shiftwidth=2
let g:netrw_banner = 0 | let mapleader = "\<Space>"
filetype indent on | syntax on | filetype plugin on
au FileType yaml setlocal ai< ci< si< 
ino jk <esc>| nn K <nop>| nn U <nop>
com! Qa qa | com! QA qa | com! Q q|                                                             " typo friendly commands. 'w' commands are separate lines (not |) Parser treats | as filename
com! WQ wq
com! Wq wq
com! W w
com! E Explore|                                                                                 " Enforce Explore shorthand command (in case of ambiguity eg. Emmet)
vm < <gv | vm > >gv|                                                                            " visual mode indenting
vn <leader>s "vy :%s/<C-R>v//g<Left><Left>|                                                     " search visual
vn <leader>S "vy :%s//<C-R>v/g<C-b><Right><Right><Right>|                                       " search visual
nn <leader>s :%sno/<C-R><C-W>//g<Left><Left>|                                                   " search
nn <leader>S :%sno//<C-R><C-W>/g<C-b><Right><Right><Right><Right><Right>|                       " search 
nn <leader>z :noh<CR>                                                                           " search  highlight
nn <leader>0 :set scroll=0<CR>                                                                  " scroll reset
vn  <C-y> "*y                                                                                   " yank into clipboard 
vn  <C-p> "*p                                                                                   " paste from clipboard 
nn  <C-j> :m .+1<CR>==| nn <C-k> :m .-2<CR>==|                                                  " shuffle line one up or down Normal mode
ino <C-j> <Esc>:m .+1<CR>==gi| ino <C-k> <Esc>:m .-2<CR>==gi|                                   " shuffle line one up or down Insert mode
vn  <C-j> :m '>+1<CR>gv=gv| vn <C-k> :m '<-2<CR>gv=gv|                                          " shuffle line one up or down Visual mode
nn <C-w>v :echo "disabled"<CR>
nn <C-w>s :echo "disabled"<CR>
nor <leader>; :call nerdcommenter#Comment(1, 'toggle')<CR>|                                     " NERD commenter installed in setup.sh
nn <leader><leader> :FuzzyFilesRoot<CR>|                              
nn <leader>/ :FuzzyGrep<CR>|
nn <leader>. :FuzzyInBuffer<CR>|
cno <C-a> <Home>
cno <C-e> <End>
nnor // <Nop>
let g:fuzzyy_keymaps = {'preview_up_half_page':[], 'delete_all': ["\<c-u>"]}
" git directory aware vim contexts. Preserves viminfo and jumps in each git repro
fu! GitPath() " Get git file path and hash it to map filenames to repros
  let dir = trim(system('git rev-parse --show-toplevel 2>/dev/null'))
  return '/tmp/'.(v:shell_error ? 'global' : trim(system('echo ' . dir . ' | md5')))
endf
fu! OnBlur() " write git repo aware viminfo
  let f=GitPath()
  exe 'wviminfo! '.f.'.viminfo'
  call writefile([expand('%:p').":".line('.')], f.'.file') 
endf
fu! OnFocus() " write last opened file in repo and restore git aware viminfo. 
  sil! exe 'rviminfo! '.GitPath().'.viminfo' | redraw! | noh | " redraw to clear any focus ansi glitches. disable current highlight due to glitches with newlines being selected on focus
endf
fu! OnEnter() " open last opened file in repo and restore git aware viminfo
  let f=GitPath() 
  if get(argv(), 0, '') == 'restore' && filereadable(f.'.file') 
    let b = split(get(readfile(f.'.file'), 0, ':'), ':')
    if len(b) > 1 | exe 'e '.b[0] | call cursor(b[1], 0) | noh | endif
  endif
  sil! exe 'rviminfo! '.f.'.viminfo'
endf
au TextYankPost,VimLeave,FocusLost * call OnBlur()
au FocusGained * call OnFocus()
au VimEnter * nested call OnEnter() | "nested to allow filetype detect to work
" BQN
let a ='`1234567890-= ~!@#$%^&*()_+ qwertyuiop[]  QWERTYUIOP{} asdfghjkl;''\ ASDFGHJKL:"| zxcvbnm,./    ZXCVBNM<>?   '
let b ='ÀúÀò¬®‚Åº‚åú¬¥Àù7‚àû¬Ø‚Ä¢√∑√ó ¬¨‚éâ‚öá‚çü‚ó∂‚äò‚éä‚çé‚çï‚ü®‚ü©‚àö‚ãÜ ‚åΩùï®‚àä‚Üë‚àßy‚äî‚äè‚äêœÄ‚Üê‚Üí  ‚Üôùïé‚ç∑ùï£‚çãYU‚äë‚äí‚ç≥‚ä£‚ä¢ ‚çâùï§‚Üïùïóùïò‚ä∏‚àò‚óã‚üú‚ãÑ‚Ü©\  ‚ÜñùïäDùîΩùîæ¬´J‚åæ¬ª¬∑Àô| ‚•äùï©‚Üì‚à®‚åän‚â°‚àæ‚âç‚â†    ‚ãàùïèC‚çí‚åàN‚â¢‚â§‚â•‚áê   '
let c ='AESsTtoNkyRrij0123)!@#*-_|'
let d ="‚àÄ‚àÉ‚ñ†‚ñ°‚óÄ‚óÅ‚óã‚Ñï‚úì‚ò∫‚Ñù‚Ü∫·µ¢‚±º‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚Å∞¬π¬≤¬≥Íòé‚Åø‚Çô|"
let[a,b]=map([a,b],{i,x->split(x,'\zs *')}) | let a+=['<space>']|let b+=['‚Äø']
for l in ['i','c']|for i in range(len(a))|exe escape(l.'no'.'\'.a[i].' '.b[i],'|')|endfor|endfor
for l in ['i','c']|for i in range(len(c))|exe escape(l.'no'.'|'.c[i].' '.matchstr(d,'.',0,i+1),'|')|endfor|endfor
unl a b c d l i
au BufRead,BufNewFile * if getline(1) =~ '^#!.*bqn$' | setf bqn | endif
au BufRead,BufNewFile *.bqn setf bqn
au FileType bqn syn match bqncom "#.*$"
au FileType bqn hi link bqncom comment
au FileType bqn setlocal softtabstop=2 tabstop=2 shiftwidth=2 expandtab cms=#%s
fu FmtBQN() 
    let c=join(getline(1, '$'), "\n")
    let t=tempname()
    let f=<<EOF 
    c‚Üê‚Ä¢FLines "/dev/stdin"
    [a,b]‚Üê‚çâ>2‚ä∏‚Üë¬®c‚äîÀú¬®1‚åä+`¬®('#'=c)‚àß¬¨‚â†`‚ä∏>¬®'"'=c  # separate code (a) and comments (b). Avoid # characters in strings
    m‚Üê{¬¨‚àß¬¥' '‚ä∏=ùï©}¬®a                           # remove tail whitespace from code
    a‚Ü©{‚åΩ(‚à®`' '‚ä∏‚â†)‚ä∏/‚åΩùï©}¬®‚åæ(m‚ä∏/)a
    s‚Üê' '¬®¬®‚Üï¬®(m‚àß(0‚â†‚â†¬®b)‚àß0‚â†‚â†¬®a)√ó1+(‚åà¬¥‚â†¬®a)-‚â†¬®a  # calculate comment prefix whitespace 
    ‚Ä¢Out 1‚Üì‚àæ‚àæ(@+10)‚ä∏‚àæ¬®<Àò‚çâ[a,s‚àæ¬®b]             # prepend whitespace and recombine code and comments
EOF
    call writefile(f, t)
    let o = system('bqn '. t, c)
    call setline(1, split(o, "\n",1))
    call delete(t)
endf
nor <leader>ff :call FmtBQN()<CR>
